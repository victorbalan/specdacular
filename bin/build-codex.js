#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// Colors
const cyan = '\x1b[36m';
const green = '\x1b[32m';
const yellow = '\x1b[33m';
const dim = '\x1b[2m';
const reset = '\x1b[0m';

const ROOT = path.join(__dirname, '..');
const COMMANDS_DIR = path.join(ROOT, 'commands', 'specd');
const WORKFLOWS_DIR = path.join(ROOT, 'specdacular', 'workflows');
const REFERENCES_DIR = path.join(ROOT, 'specdacular', 'references');
const OUTPUT_DIR = path.join(ROOT, 'codex', 'skills');

const AUTO_GENERATED_HEADER = `<!-- AUTO-GENERATED by bin/build-codex.js — DO NOT EDIT DIRECTLY -->\n<!-- Source: Claude Code commands + workflows. Run: npm run build:codex -->\n\n`;

// Tool translation table (prose-level replacements, order matters — longest first)
const TOOL_TRANSLATIONS = [
  ['use the Read tool', 'use `cat -n`'],
  ['Use the Read tool', 'Use `cat -n`'],
  ['the Read tool', '`cat -n`'],
  ['Read tool', '`cat -n`'],
  ['use the Write tool', 'write the file'],
  ['Use the Write tool', 'Write the file'],
  ['the Write tool', 'file writing'],
  ['Write tool', 'file writing'],
  ['use the Edit tool', 'use `sed` or manual editing'],
  ['Use the Edit tool', 'Use `sed` or manual editing'],
  ['the Edit tool', '`sed` / manual editing'],
  ['Edit tool', '`sed` / manual editing'],
  ['use the Grep tool', 'use `rg`'],
  ['Use the Grep tool', 'Use `rg`'],
  ['use Grep', 'use `rg`'],
  ['Use Grep', 'Use `rg`'],
  ['the Grep tool', '`rg`'],
  ['Grep tool', '`rg`'],
  ['use the Glob tool', 'use `find`'],
  ['Use the Glob tool', 'Use `find`'],
  ['use Glob', 'use `find`'],
  ['Use Glob', 'Use `find`'],
  ['the Glob tool', '`find`'],
  ['Glob tool', '`find`'],
  ['use the Bash tool', 'run a shell command'],
  ['Use the Bash tool', 'Run a shell command'],
  ['the Bash tool', 'the shell'],
  ['Bash tool', 'the shell'],
  ['AskUserQuestion', 'ask_user_question'],
  ['use the Task tool', 'perform the following steps sequentially'],
  ['Use the Task tool', 'Perform the following steps sequentially'],
  ['Task tool', 'sequential execution'],
];

/**
 * Parse YAML frontmatter from markdown content.
 * Returns { frontmatter: {}, body: string }
 */
function parseFrontmatter(content) {
  if (!content.startsWith('---')) return { frontmatter: {}, body: content };
  const end = content.indexOf('---', 3);
  if (end === -1) return { frontmatter: {}, body: content };
  const yaml = content.slice(3, end).trim();
  const fm = {};
  let currentKey = null;
  let currentList = null;
  for (const line of yaml.split('\n')) {
    const listMatch = line.match(/^\s+-\s+(.+)/);
    if (listMatch && currentKey) {
      if (!currentList) { currentList = []; fm[currentKey] = currentList; }
      currentList.push(listMatch[1].trim());
      continue;
    }
    const kvMatch = line.match(/^(\w[\w-]*)\s*:\s*(.*)/);
    if (kvMatch) {
      currentKey = kvMatch[1];
      const val = kvMatch[2].trim();
      currentList = null;
      if (val) {
        fm[currentKey] = val.replace(/^["']|["']$/g, '');
      }
    }
  }
  return { frontmatter: fm, body: content.slice(end + 3).trim() };
}

/**
 * Extract workflow filename from <execution_context> block.
 * Matches @~/.claude/specdacular/workflows/{name}.md or @{path}/specdacular/workflows/{name}.md
 */
function extractWorkflowRef(body) {
  const match = body.match(/@[^\s]*specdacular\/workflows\/([^\s<]+\.md)/);
  return match ? match[1] : null;
}

/**
 * Apply tool translations to content.
 */
function translateTools(content) {
  let result = content;
  for (const [from, to] of TOOL_TRANSLATIONS) {
    result = result.split(from).join(to);
  }
  return result;
}

/**
 * Replace @~/.claude/ and similar path references.
 * Order matters — specific rules first, then catch-alls.
 */
function replacePathRefs(content) {
  let result = content;

  // 1. Cross-workflow references → skill pointers (most specific)
  result = result.replace(/@[^\s<)]*specdacular\/workflows\/([^\s<).]+)\.md/g, function(match, name) {
    return '(see skill: specd-' + name + ')';
  });

  // 2. Cross-reference file references → local markdown links
  result = result.replace(/@[^\s<)]*specdacular\/references\/([^\s<)]+\.md)/g, function(match, name) {
    return '[' + name + '](references/' + name + ')';
  });

  // 3. Remaining @~/.claude/specdacular/ references → see references/
  result = result.replace(/@~\/\.claude\/specdacular\/[^\s<)]+/g, '(see references/)');

  // 4. Remaining @/abs/path/specdacular/ references → see references/
  result = result.replace(/@\/[^\s<)]*specdacular\/[^\s<)]+/g, '(see references/)');

  // 5. Remaining @~/.claude/ references
  result = result.replace(/@~\/\.claude\/[^\s<)]+/g, '(removed for Codex)');

  // 6. Backtick-wrapped ~/.claude/ paths
  result = result.replace(/`~\/\.claude\/([^`]+)`/g, '`.codex/$1`');

  // 7. Bare ~/.claude/ paths (not in backticks, not @-prefixed)
  result = result.replace(/(?<![@`])~\/\.claude\//g, '.codex/');

  return result;
}

/**
 * Copy shared references that the workflow uses into the skill's references/ dir.
 */
function copySharedRefs(workflowContent, refsDir) {
  var refPattern = /@[^\s]*specdacular\/references\/([^\s<)]+\.md)/g;
  var match;
  var copied = [];
  while ((match = refPattern.exec(workflowContent)) !== null) {
    var refName = match[1];
    if (copied.indexOf(refName) !== -1) continue; // skip duplicates
    var srcPath = path.join(REFERENCES_DIR, refName);
    if (fs.existsSync(srcPath)) {
      var refContent = fs.readFileSync(srcPath, 'utf8');
      refContent = translateTools(refContent);
      refContent = replacePathRefs(refContent);
      fs.writeFileSync(path.join(refsDir, refName), AUTO_GENERATED_HEADER + refContent);
      copied.push(refName);
    }
  }
  return copied;
}

/**
 * Escape a string for YAML (quote if it contains special chars).
 */
function yamlQuote(str) {
  if (/[:#{}[\],&*?|>!%@`]/.test(str) || str.startsWith('"') || str.startsWith("'")) {
    return '"' + str.replace(/"/g, '\\"') + '"';
  }
  return str;
}

/**
 * Generate SKILL.md content (brief entry point).
 */
function generateSkillMd(commandFm, commandBody) {
  const skillName = commandFm.name.replace(/:/g, '-');
  const description = yamlQuote(commandFm.description);
  const fm = `---\nname: ${skillName}\ndescription: ${description}\n---\n\n`;

  // Remove <execution_context> block, keep the rest
  let body = commandBody.replace(/<execution_context>[\s\S]*?<\/execution_context>\s*/g, '').trim();
  body = translateTools(body);
  body = replacePathRefs(body);

  return AUTO_GENERATED_HEADER + fm + body + '\n\nSee [full workflow](references/workflow.md) for detailed steps.\n';
}

/**
 * Generate references/workflow.md (full translated workflow).
 */
function generateWorkflowMd(workflowContent) {
  let result = translateTools(workflowContent);
  result = replacePathRefs(result);
  return AUTO_GENERATED_HEADER + result;
}

/**
 * Discover all command .md files recursively.
 * Returns [{ name: 'help', path: '/abs/path' }, { name: 'feature-new', path: '...' }]
 */
function discoverCommands(dir, prefix) {
  prefix = prefix || '';
  const results = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    if (entry.isDirectory()) {
      results.push(...discoverCommands(path.join(dir, entry.name), prefix + entry.name + '-'));
    } else if (entry.name.endsWith('.md')) {
      const name = prefix + entry.name.replace('.md', '');
      results.push({ name, path: path.join(dir, entry.name) });
    }
  }
  return results;
}

/**
 * Main build function.
 */
function main() {
  console.log(`${cyan}Building Codex skills...${reset}\n`);

  // Clean output
  if (fs.existsSync(OUTPUT_DIR)) {
    fs.rmSync(OUTPUT_DIR, { recursive: true });
  }

  const commands = discoverCommands(COMMANDS_DIR);
  let generated = 0;
  let skipped = 0;

  for (const cmd of commands) {
    const content = fs.readFileSync(cmd.path, 'utf8');
    const { frontmatter: fm, body } = parseFrontmatter(content);

    if (!fm.name || !fm.description) {
      console.log(`  ${yellow}⚠${reset} Skipping ${cmd.name}: missing name or description`);
      skipped++;
      continue;
    }

    // Find workflow
    const workflowRef = extractWorkflowRef(body);
    let workflowContent = null;
    if (workflowRef) {
      const workflowPath = path.join(WORKFLOWS_DIR, workflowRef);
      if (fs.existsSync(workflowPath)) {
        workflowContent = fs.readFileSync(workflowPath, 'utf8');
      } else {
        console.log(`  ${yellow}⚠${reset} Workflow not found for ${cmd.name}: ${workflowRef}`);
      }
    }

    // Generate skill directory
    const skillName = fm.name.replace(/:/g, '-');
    const skillDir = path.join(OUTPUT_DIR, skillName);
    const refsDir = path.join(skillDir, 'references');
    fs.mkdirSync(refsDir, { recursive: true });

    // Write SKILL.md
    const skillMd = generateSkillMd(fm, body);
    fs.writeFileSync(path.join(skillDir, 'SKILL.md'), skillMd);

    // Write references/workflow.md (if workflow found)
    if (workflowContent) {
      const translatedWorkflow = generateWorkflowMd(workflowContent);
      fs.writeFileSync(path.join(refsDir, 'workflow.md'), translatedWorkflow);

      // Copy shared references used by this workflow
      const refs = copySharedRefs(workflowContent, refsDir);
      if (refs.length > 0) {
        console.log(`    ${dim}+ refs: ${refs.join(', ')}${reset}`);
      }
    }

    generated++;
    console.log(`  ${green}✓${reset} ${skillName}`);
  }

  console.log(`\n${green}Done:${reset} ${generated} skills generated, ${skipped} skipped.`);
}

main();
