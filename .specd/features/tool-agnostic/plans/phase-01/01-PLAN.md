---
feature: tool-agnostic
phase: 1
plan: 01
depends_on: []
creates:
  - bin/build-codex.js
  - codex/skills/specd-help/SKILL.md
  - codex/skills/specd-help/references/workflow.md
modifies:
  - package.json
---

# Plan 01: Build Script Foundation

## Objective

Create `bin/build-codex.js` that reads Claude Code command+workflow pairs and generates Codex skill directories with correct frontmatter, tool reference translation, and path replacement. Verify with the simplest case: the `help` command.

## Context

**Reference these files:**
- `@bin/install.js` — Pattern for Node.js scripts in this project (zero-dep, color output, `fs`/`path`/`os` only)
- `@commands/specd/help.md` — Simplest command (input example)
- `@commands/specd/status.md` — Command with nested tools and `@path` reference (input example)
- `@.specd/codebase/PATTERNS.md` — Code patterns

**Relevant Decisions:**
- DEC-001: Generator approach — `bin/build-codex.js` reads Claude Code source, produces `codex/` output
- DEC-003: Generated files committed to repository — `codex/` is checked in
- DEC-004: Skill directory pattern — each command+workflow becomes `codex/skills/specd-{name}/SKILL.md` + `references/workflow.md`
- DEC-006: Pre-commit hook — auto-generated header comment in all files

**From Research:**
- Codex SKILL.md frontmatter: only `name` and `description` (YAML), no `allowed-tools`, `argument-hint`, etc.
- Codex references/ folder: standard markdown links, loaded on demand
- Tool translation table: Read→`cat -n`, Grep→`rg`, Glob→`find`, Write→file write, Edit→`sed`/`apply_patch`, Task→sequential fallback, AskUserQuestion→`ask_user_question`
- `@~/.claude/` path references must be replaced
- YAML frontmatter must validate (colons in descriptions need quoting — Codex silently skips invalid YAML, GitHub issue #8609)
- XML-style tags (`<step>`, `<process>`, etc.) can stay as-is

---

## Tasks

### Task 1: Create core build script structure

**Files:** `bin/build-codex.js`

**Action:**
Create the build script with the following structure. Follow the pattern from `bin/install.js` — zero dependencies, colors, clear output.

The script should:
1. Discover all command files: scan `commands/specd/` recursively for `*.md` files
2. For each command, extract YAML frontmatter (`name`, `description`, `allowed-tools`, `argument-hint`)
3. Find the corresponding workflow: parse the `@~/.claude/specdacular/workflows/{name}.md` reference from the command's `<execution_context>` block
4. Handle nested commands: `commands/specd/feature/new.md` → skill name `specd-feature-new`, workflow from `<execution_context>` reference
5. Generate output directory: `codex/skills/specd-{name}/`

**Core structure:**

```javascript
#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

const ROOT = path.join(__dirname, '..');
const COMMANDS_DIR = path.join(ROOT, 'commands', 'specd');
const WORKFLOWS_DIR = path.join(ROOT, 'specdacular', 'workflows');
const OUTPUT_DIR = path.join(ROOT, 'codex', 'skills');

const AUTO_GENERATED_HEADER = `<!-- AUTO-GENERATED by bin/build-codex.js — DO NOT EDIT DIRECTLY -->\n<!-- Source: Claude Code commands + workflows. Run: npm run build:codex -->\n\n`;

// Tool translation table (prose-level replacements, order matters — longest first)
const TOOL_TRANSLATIONS = [
  ['use the Read tool', 'use `cat -n`'],
  ['Use the Read tool', 'Use `cat -n`'],
  ['the Read tool', '`cat -n`'],
  ['Read tool', '`cat -n`'],
  ['use the Write tool', 'write the file'],
  ['Use the Write tool', 'Write the file'],
  ['the Write tool', 'file writing'],
  ['Write tool', 'file writing'],
  ['use the Edit tool', 'use `sed` or manual editing'],
  ['Use the Edit tool', 'Use `sed` or manual editing'],
  ['the Edit tool', '`sed` / manual editing'],
  ['Edit tool', '`sed` / manual editing'],
  ['use the Grep tool', 'use `rg`'],
  ['Use the Grep tool', 'Use `rg`'],
  ['use Grep', 'use `rg`'],
  ['Use Grep', 'Use `rg`'],
  ['the Grep tool', '`rg`'],
  ['Grep tool', '`rg`'],
  ['use the Glob tool', 'use `find`'],
  ['Use the Glob tool', 'Use `find`'],
  ['use Glob', 'use `find`'],
  ['Use Glob', 'Use `find`'],
  ['the Glob tool', '`find`'],
  ['Glob tool', '`find`'],
  ['use the Bash tool', 'run a shell command'],
  ['Use the Bash tool', 'Run a shell command'],
  ['the Bash tool', 'the shell'],
  ['Bash tool', 'the shell'],
  ['AskUserQuestion', 'ask_user_question'],
  ['use the Task tool', 'perform the following steps sequentially'],
  ['Use the Task tool', 'Perform the following steps sequentially'],
  ['Task tool', 'sequential execution'],
];

/**
 * Parse YAML frontmatter from markdown content.
 * Returns { frontmatter: {}, body: string }
 */
function parseFrontmatter(content) {
  // ... manual YAML parse (key: value lines between --- delimiters)
}

/**
 * Extract workflow path from <execution_context> block.
 * Returns the workflow filename or null.
 */
function extractWorkflowRef(body) {
  // Match @~/.claude/specdacular/workflows/{name}.md
  // or @{pathPrefix}specdacular/workflows/{name}.md
}

/**
 * Apply tool translations to content.
 */
function translateTools(content) {
  let result = content;
  for (const [from, to] of TOOL_TRANSLATIONS) {
    result = result.split(from).join(to);
  }
  return result;
}

/**
 * Replace @~/.claude/ path references.
 */
function replacePathRefs(content) {
  // Replace @~/.claude/specdacular/ → See references/
  // Replace @~/.claude/ → (removed for Codex)
}

/**
 * Generate Codex SKILL.md frontmatter from command frontmatter.
 */
function generateSkillFrontmatter(commandFm) {
  // Only name + description, properly quoted
}

/**
 * Generate SKILL.md content (brief entry point).
 */
function generateSkillMd(commandFm, commandBody) {
  // Auto-generated header + frontmatter + adapted command body
  // Reference workflow: "See [workflow](references/workflow.md)"
}

/**
 * Generate references/workflow.md (full translated workflow).
 */
function generateWorkflowMd(workflowContent) {
  // Auto-generated header + translateTools + replacePathRefs
}

// Main
function main() {
  // 1. Clean output dir
  // 2. Discover commands
  // 3. For each command: parse, find workflow, generate skill dir
  // 4. Print summary
}

main();
```

**Key implementation details:**

For frontmatter parsing, do NOT use a YAML library (zero-dep constraint). Parse manually:
```javascript
function parseFrontmatter(content) {
  if (!content.startsWith('---')) return { frontmatter: {}, body: content };
  const end = content.indexOf('---', 3);
  if (end === -1) return { frontmatter: {}, body: content };
  const yaml = content.slice(3, end).trim();
  const fm = {};
  let currentKey = null;
  let currentList = null;
  for (const line of yaml.split('\n')) {
    const listMatch = line.match(/^\s+-\s+(.+)/);
    if (listMatch && currentKey) {
      if (!currentList) { currentList = []; fm[currentKey] = currentList; }
      currentList.push(listMatch[1].trim());
      continue;
    }
    const kvMatch = line.match(/^(\w[\w-]*)\s*:\s*(.*)/);
    if (kvMatch) {
      currentKey = kvMatch[1];
      const val = kvMatch[2].trim();
      currentList = null;
      if (val) {
        fm[currentKey] = val.replace(/^["']|["']$/g, '');
      }
    }
  }
  return { frontmatter: fm, body: content.slice(end + 3).trim() };
}
```

For command discovery (handle nested dirs like `commands/specd/feature/`):
```javascript
function discoverCommands(dir, prefix = '') {
  const results = [];
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    if (entry.isDirectory()) {
      results.push(...discoverCommands(path.join(dir, entry.name), prefix + entry.name + '-'));
    } else if (entry.name.endsWith('.md')) {
      const name = prefix + entry.name.replace('.md', '');
      results.push({ name, path: path.join(dir, entry.name) });
    }
  }
  return results;
}
```

For SKILL.md generation — the command body references a workflow via `<execution_context>`. In Codex, replace this with a standard markdown link:
```javascript
function generateSkillMd(commandFm, commandBody) {
  const fm = `---\nname: specd-${commandFm.name.replace(/:/g, '-')}\ndescription: "${commandFm.description}"\n---\n\n`;
  // Remove <execution_context> block, add reference link instead
  let body = commandBody.replace(/<execution_context>[\s\S]*?<\/execution_context>/g, '').trim();
  body = translateTools(body);
  body = replacePathRefs(body);
  return AUTO_GENERATED_HEADER + fm + body + '\n\nSee [full workflow](references/workflow.md) for detailed steps.\n';
}
```

**Verify:**
```bash
node bin/build-codex.js 2>&1 | head -20
```

**Done when:**
- [ ] `bin/build-codex.js` runs without errors
- [ ] Discovers all command files (including nested `feature/` directory)
- [ ] Parses frontmatter correctly
- [ ] Finds corresponding workflow files

---

### Task 2: Generate skill output and verify with help command

**Files:** `bin/build-codex.js`, `package.json`

**Action:**
Complete the main() function to generate actual output, then add the `build:codex` npm script.

**Main function implementation:**
```javascript
function main() {
  console.log('Building Codex skills...\n');

  // Clean output
  if (fs.existsSync(OUTPUT_DIR)) {
    fs.rmSync(OUTPUT_DIR, { recursive: true });
  }

  const commands = discoverCommands(COMMANDS_DIR);
  let generated = 0;
  let skipped = 0;

  for (const cmd of commands) {
    const content = fs.readFileSync(cmd.path, 'utf8');
    const { frontmatter: fm, body } = parseFrontmatter(content);

    if (!fm.name || !fm.description) {
      console.log(`  ⚠ Skipping ${cmd.name}: missing name or description`);
      skipped++;
      continue;
    }

    // Find workflow
    const workflowRef = extractWorkflowRef(body);
    let workflowContent = null;
    if (workflowRef) {
      const workflowPath = path.join(WORKFLOWS_DIR, workflowRef);
      if (fs.existsSync(workflowPath)) {
        workflowContent = fs.readFileSync(workflowPath, 'utf8');
      } else {
        console.log(`  ⚠ Workflow not found for ${cmd.name}: ${workflowRef}`);
      }
    }

    // Generate skill directory
    const skillName = 'specd-' + fm.name.replace(/:/g, '-');
    const skillDir = path.join(OUTPUT_DIR, skillName);
    const refsDir = path.join(skillDir, 'references');
    fs.mkdirSync(refsDir, { recursive: true });

    // Write SKILL.md
    const skillMd = generateSkillMd(fm, body);
    fs.writeFileSync(path.join(skillDir, 'SKILL.md'), skillMd);

    // Write references/workflow.md (if workflow found)
    if (workflowContent) {
      const translatedWorkflow = AUTO_GENERATED_HEADER + translateTools(replacePathRefs(workflowContent));
      fs.writeFileSync(path.join(refsDir, 'workflow.md'), translatedWorkflow);
    }

    generated++;
    console.log(`  ✓ ${skillName}`);
  }

  console.log(`\nDone: ${generated} skills generated, ${skipped} skipped.`);
}
```

**Add to `package.json`:**
```json
"scripts": {
  "build:codex": "node bin/build-codex.js"
}
```

Note: `package.json` currently has no `scripts` field — add it.

**Verify:**
```bash
node bin/build-codex.js && cat codex/skills/specd-help/SKILL.md
```

Expected SKILL.md for help:
```markdown
<!-- AUTO-GENERATED by bin/build-codex.js — DO NOT EDIT DIRECTLY -->
<!-- Source: Claude Code commands + workflows. Run: npm run build:codex -->

---
name: specd-help
description: "Show all specdacular commands and usage guide"
---

Read the file at ... and output its entire contents to the user as-is. Do not summarize, truncate, or add commentary.

See [full workflow](references/workflow.md) for detailed steps.
```

**Also verify:**
- No `allowed-tools:` in generated SKILL.md
- No `@~/.claude/` paths in generated files
- No Claude Code tool names (Read, Write, Grep, Glob) in generated workflow.md
- Auto-generated header present in all files

```bash
# Check no Claude Code tool references remain
grep -r "Read tool\|Write tool\|Grep tool\|Glob tool\|Bash tool" codex/ && echo "FAIL: tool references found" || echo "PASS: no tool references"

# Check no @~/.claude/ paths remain
grep -r "@~/.claude/" codex/ && echo "FAIL: path references found" || echo "PASS: no path references"

# Check auto-generated header
head -1 codex/skills/specd-help/SKILL.md | grep "AUTO-GENERATED" && echo "PASS: header present" || echo "FAIL: no header"

# Check YAML frontmatter is valid (name + description only)
head -5 codex/skills/specd-help/SKILL.md
```

**Done when:**
- [ ] `node bin/build-codex.js` generates `codex/skills/specd-help/` directory
- [ ] SKILL.md has correct Codex frontmatter (name + description only, YAML valid)
- [ ] `references/workflow.md` has translated tool references
- [ ] No `@~/.claude/` paths in any generated file
- [ ] No Claude Code tool names in generated files
- [ ] Auto-generated header present in all generated files
- [ ] `npm run build:codex` works via package.json script
- [ ] Script generates skill directories for ALL discovered commands (even if some workflows missing)

---

## Verification

After all tasks complete:

```bash
# Full build
node bin/build-codex.js

# Check output structure
find codex/ -type f | sort

# Verify help skill specifically
cat codex/skills/specd-help/SKILL.md

# No Claude Code artifacts remain
grep -r "Read tool\|Write tool\|Grep tool\|Glob tool\|allowed-tools:" codex/ && echo "FAIL" || echo "PASS"
grep -r "@~/.claude/" codex/ && echo "FAIL" || echo "PASS"

# Auto-generated headers
for f in $(find codex/ -name "*.md"); do head -1 "$f" | grep -q "AUTO-GENERATED" || echo "Missing header: $f"; done

# npm script works
npm run build:codex
```

**Plan is complete when:**
- [ ] All tasks marked done
- [ ] All verification commands pass
- [ ] `bin/build-codex.js` handles all command files (including nested)
- [ ] Help skill generates correctly as proof of concept

---

## Output

When this plan is complete:

1. Update `.specd/features/tool-agnostic/STATE.md`:
   - Mark this plan as complete
   - Note any discoveries or decisions made

2. Commit changes:
   ```bash
   git add bin/build-codex.js codex/ package.json
   git commit -m "feat(tool-agnostic): add Codex build script foundation

   Plan 1.01 complete:
   - bin/build-codex.js generates Codex skill directories from Claude Code source
   - Tool reference translation (Read→cat, Grep→rg, etc.)
   - Path reference replacement (@~/.claude/ removed)
   - Auto-generated headers in all output files
   - npm run build:codex script added"
   ```

3. Next: Phase 2 — Easy Workflow Conversion (6 simple skills)

---

## Implementation Log

_Empty — to be filled during execution._

---

## Notes

The help command is the simplest case — it has only `Read` as an allowed tool and a one-line body. This makes it ideal for validating the build pipeline end-to-end before scaling to complex workflows in Phase 2.

Commands in `commands/specd/feature/` are nested — the script must handle this by prefixing with the directory name (e.g., `feature/new.md` → skill name `specd-feature-new`, matching the `:` → `-` convention from `specd:feature:new`).
